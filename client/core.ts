// @generated by protobuf-ts 2.9.3
// @generated from protobuf file "core.proto" (package "aelf", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message aelf.Transaction
 */
export interface Transaction {
    /**
     * The address of the sender of the transaction.
     *
     * @generated from protobuf field: aelf.Address from = 1;
     */
    from?: Address;
    /**
     * The address of the contract when calling a contract.
     *
     * @generated from protobuf field: aelf.Address to = 2;
     */
    to?: Address;
    /**
     * The height of the referenced block hash.
     *
     * @generated from protobuf field: int64 ref_block_number = 3;
     */
    refBlockNumber: bigint;
    /**
     * The first four bytes of the referenced block hash.
     *
     * @generated from protobuf field: bytes ref_block_prefix = 4;
     */
    refBlockPrefix: Uint8Array;
    /**
     * The name of a method in the smart contract at the To address.
     *
     * @generated from protobuf field: string method_name = 5;
     */
    methodName: string;
    /**
     * The parameters to pass to the smart contract method.
     *
     * @generated from protobuf field: bytes params = 6;
     */
    params: Uint8Array;
    /**
     * When signing a transaction itâ€™s actually a subset of the fields: from/to and the target method as well as
     * the parameter that were given. It also contains the reference block number and prefix.
     *
     * @generated from protobuf field: bytes signature = 10000;
     */
    signature: Uint8Array;
}
/**
 * @generated from protobuf message aelf.StatePath
 */
export interface StatePath {
    /**
     * The partial path of the state path.
     *
     * @generated from protobuf field: repeated string parts = 1;
     */
    parts: string[];
}
/**
 * @generated from protobuf message aelf.ScopedStatePath
 */
export interface ScopedStatePath {
    /**
     * The scope address, which will be the contract address.
     *
     * @generated from protobuf field: aelf.Address address = 1;
     */
    address?: Address;
    /**
     * The path of contract state.
     *
     * @generated from protobuf field: aelf.StatePath path = 2;
     */
    path?: StatePath;
}
/**
 * @generated from protobuf message aelf.TransactionResult
 */
export interface TransactionResult {
    /**
     * The transaction id.
     *
     * @generated from protobuf field: aelf.Hash transaction_id = 1;
     */
    transactionId?: Hash;
    /**
     * The transaction result status.
     *
     * @generated from protobuf field: aelf.TransactionResultStatus status = 2;
     */
    status: TransactionResultStatus;
    /**
     * The log events.
     *
     * @generated from protobuf field: repeated aelf.LogEvent logs = 3;
     */
    logs: LogEvent[];
    /**
     * Bloom filter for transaction logs. A transaction log event can be defined in the contract and stored
     * in the bloom filter after the transaction is executed. Through this filter, we can quickly search for
     * and determine whether a log exists in the transaction result.
     *
     * @generated from protobuf field: bytes bloom = 4;
     */
    bloom: Uint8Array;
    /**
     * The return value of the transaction execution.
     *
     * @generated from protobuf field: bytes return_value = 5;
     */
    returnValue: Uint8Array;
    /**
     * The height of the block hat packages the transaction.
     *
     * @generated from protobuf field: int64 block_number = 6;
     */
    blockNumber: bigint;
    /**
     * The hash of the block hat packages the transaction.
     *
     * @generated from protobuf field: aelf.Hash block_hash = 7;
     */
    blockHash?: Hash;
    /**
     * Failed execution error message.
     *
     * @generated from protobuf field: string error = 10;
     */
    error: string;
}
/**
 * @generated from protobuf message aelf.LogEvent
 */
export interface LogEvent {
    /**
     * The contract address.
     *
     * @generated from protobuf field: aelf.Address address = 1;
     */
    address?: Address;
    /**
     * The name of the log event.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The indexed data, used to calculate bloom.
     *
     * @generated from protobuf field: repeated bytes indexed = 3;
     */
    indexed: Uint8Array[];
    /**
     * The non indexed data.
     *
     * @generated from protobuf field: bytes non_indexed = 4;
     */
    nonIndexed: Uint8Array;
}
/**
 * @generated from protobuf message aelf.SmartContractRegistration
 */
export interface SmartContractRegistration {
    /**
     * The category of contract code(0: C#).
     *
     * @generated from protobuf field: sint32 category = 1;
     */
    category: number;
    /**
     * The byte array of the contract code.
     *
     * @generated from protobuf field: bytes code = 2;
     */
    code: Uint8Array;
    /**
     * The hash of the contract code.
     *
     * @generated from protobuf field: aelf.Hash code_hash = 3;
     */
    codeHash?: Hash;
    /**
     * Whether it is a system contract.
     *
     * @generated from protobuf field: bool is_system_contract = 4;
     */
    isSystemContract: boolean;
    /**
     * The version of the current contract.
     *
     * @generated from protobuf field: int32 version = 5;
     */
    version: number;
}
/**
 * @generated from protobuf message aelf.TransactionExecutingStateSet
 */
export interface TransactionExecutingStateSet {
    /**
     * The changed states.
     *
     * @generated from protobuf field: map<string, bytes> writes = 1;
     */
    writes: {
        [key: string]: Uint8Array;
    };
    /**
     * The read states.
     *
     * @generated from protobuf field: map<string, bool> reads = 2;
     */
    reads: {
        [key: string]: boolean;
    };
    /**
     * The deleted states.
     *
     * @generated from protobuf field: map<string, bool> deletes = 3;
     */
    deletes: {
        [key: string]: boolean;
    };
}
/**
 * @generated from protobuf message aelf.Address
 */
export interface Address {
    /**
     * @generated from protobuf field: bytes value = 1;
     */
    value: Uint8Array;
}
/**
 * @generated from protobuf message aelf.Hash
 */
export interface Hash {
    /**
     * @generated from protobuf field: bytes value = 1;
     */
    value: Uint8Array;
}
/**
 * @generated from protobuf message aelf.SInt32Value
 */
export interface SInt32Value {
    /**
     * @generated from protobuf field: sint32 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message aelf.SInt64Value
 */
export interface SInt64Value {
    /**
     * @generated from protobuf field: sint64 value = 1;
     */
    value: bigint;
}
/**
 * @generated from protobuf message aelf.MerklePath
 */
export interface MerklePath {
    /**
     * The merkle path nodes.
     *
     * @generated from protobuf field: repeated aelf.MerklePathNode merkle_path_nodes = 1;
     */
    merklePathNodes: MerklePathNode[];
}
/**
 * @generated from protobuf message aelf.MerklePathNode
 */
export interface MerklePathNode {
    /**
     * The node hash.
     *
     * @generated from protobuf field: aelf.Hash hash = 1;
     */
    hash?: Hash;
    /**
     * Whether it is a left child node.
     *
     * @generated from protobuf field: bool is_left_child_node = 2;
     */
    isLeftChildNode: boolean;
}
/**
 * @generated from protobuf message aelf.BinaryMerkleTree
 */
export interface BinaryMerkleTree {
    /**
     * The leaf nodes.
     *
     * @generated from protobuf field: repeated aelf.Hash nodes = 1;
     */
    nodes: Hash[];
    /**
     * The root node hash.
     *
     * @generated from protobuf field: aelf.Hash root = 2;
     */
    root?: Hash;
    /**
     * The count of leaf node.
     *
     * @generated from protobuf field: int32 leaf_count = 3;
     */
    leafCount: number;
}
/**
 * @generated from protobuf message aelf.BigIntValue
 */
export interface BigIntValue {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
}
/**
 * @generated from protobuf enum aelf.TransactionResultStatus
 */
export enum TransactionResultStatus {
    /**
     * The execution result of the transaction does not exist.
     *
     * @generated from protobuf enum value: NOT_EXISTED = 0;
     */
    NOT_EXISTED = 0,
    /**
     * The transaction is in the transaction pool waiting to be packaged.
     *
     * @generated from protobuf enum value: PENDING = 1;
     */
    PENDING = 1,
    /**
     * Transaction execution failed.
     *
     * @generated from protobuf enum value: FAILED = 2;
     */
    FAILED = 2,
    /**
     * The transaction was successfully executed and successfully packaged into a block.
     *
     * @generated from protobuf enum value: MINED = 3;
     */
    MINED = 3,
    /**
     * When executed in parallel, there are conflicts with other transactions.
     *
     * @generated from protobuf enum value: CONFLICT = 4;
     */
    CONFLICT = 4,
    /**
     * The transaction is waiting for validation.
     *
     * @generated from protobuf enum value: PENDING_VALIDATION = 5;
     */
    PENDING_VALIDATION = 5,
    /**
     * Transaction validation failed.
     *
     * @generated from protobuf enum value: NODE_VALIDATION_FAILED = 6;
     */
    NODE_VALIDATION_FAILED = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("aelf.Transaction", [
            { no: 1, name: "from", kind: "message", T: () => Address },
            { no: 2, name: "to", kind: "message", T: () => Address },
            { no: 3, name: "ref_block_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "ref_block_prefix", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "method_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "params", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10000, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refBlockNumber = 0n;
        message.refBlockPrefix = new Uint8Array(0);
        message.methodName = "";
        message.params = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* aelf.Address from */ 1:
                    message.from = Address.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* aelf.Address to */ 2:
                    message.to = Address.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* int64 ref_block_number */ 3:
                    message.refBlockNumber = reader.int64().toBigInt();
                    break;
                case /* bytes ref_block_prefix */ 4:
                    message.refBlockPrefix = reader.bytes();
                    break;
                case /* string method_name */ 5:
                    message.methodName = reader.string();
                    break;
                case /* bytes params */ 6:
                    message.params = reader.bytes();
                    break;
                case /* bytes signature */ 10000:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aelf.Address from = 1; */
        if (message.from)
            Address.internalBinaryWrite(message.from, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* aelf.Address to = 2; */
        if (message.to)
            Address.internalBinaryWrite(message.to, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 ref_block_number = 3; */
        if (message.refBlockNumber !== 0n)
            writer.tag(3, WireType.Varint).int64(message.refBlockNumber);
        /* bytes ref_block_prefix = 4; */
        if (message.refBlockPrefix.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.refBlockPrefix);
        /* string method_name = 5; */
        if (message.methodName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.methodName);
        /* bytes params = 6; */
        if (message.params.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.params);
        /* bytes signature = 10000; */
        if (message.signature.length)
            writer.tag(10000, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatePath$Type extends MessageType<StatePath> {
    constructor() {
        super("aelf.StatePath", [
            { no: 1, name: "parts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatePath>): StatePath {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parts = [];
        if (value !== undefined)
            reflectionMergePartial<StatePath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatePath): StatePath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string parts */ 1:
                    message.parts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatePath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string parts = 1; */
        for (let i = 0; i < message.parts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.parts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.StatePath
 */
export const StatePath = new StatePath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedStatePath$Type extends MessageType<ScopedStatePath> {
    constructor() {
        super("aelf.ScopedStatePath", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "path", kind: "message", T: () => StatePath }
        ]);
    }
    create(value?: PartialMessage<ScopedStatePath>): ScopedStatePath {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScopedStatePath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedStatePath): ScopedStatePath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* aelf.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* aelf.StatePath path */ 2:
                    message.path = StatePath.internalBinaryRead(reader, reader.uint32(), options, message.path);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedStatePath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aelf.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* aelf.StatePath path = 2; */
        if (message.path)
            StatePath.internalBinaryWrite(message.path, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.ScopedStatePath
 */
export const ScopedStatePath = new ScopedStatePath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionResult$Type extends MessageType<TransactionResult> {
    constructor() {
        super("aelf.TransactionResult", [
            { no: 1, name: "transaction_id", kind: "message", T: () => Hash },
            { no: 2, name: "status", kind: "enum", T: () => ["aelf.TransactionResultStatus", TransactionResultStatus] },
            { no: 3, name: "logs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LogEvent },
            { no: 4, name: "bloom", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "return_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "block_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "block_hash", kind: "message", T: () => Hash },
            { no: 10, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionResult>): TransactionResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.logs = [];
        message.bloom = new Uint8Array(0);
        message.returnValue = new Uint8Array(0);
        message.blockNumber = 0n;
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<TransactionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionResult): TransactionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* aelf.Hash transaction_id */ 1:
                    message.transactionId = Hash.internalBinaryRead(reader, reader.uint32(), options, message.transactionId);
                    break;
                case /* aelf.TransactionResultStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* repeated aelf.LogEvent logs */ 3:
                    message.logs.push(LogEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes bloom */ 4:
                    message.bloom = reader.bytes();
                    break;
                case /* bytes return_value */ 5:
                    message.returnValue = reader.bytes();
                    break;
                case /* int64 block_number */ 6:
                    message.blockNumber = reader.int64().toBigInt();
                    break;
                case /* aelf.Hash block_hash */ 7:
                    message.blockHash = Hash.internalBinaryRead(reader, reader.uint32(), options, message.blockHash);
                    break;
                case /* string error */ 10:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aelf.Hash transaction_id = 1; */
        if (message.transactionId)
            Hash.internalBinaryWrite(message.transactionId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* aelf.TransactionResultStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* repeated aelf.LogEvent logs = 3; */
        for (let i = 0; i < message.logs.length; i++)
            LogEvent.internalBinaryWrite(message.logs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes bloom = 4; */
        if (message.bloom.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.bloom);
        /* bytes return_value = 5; */
        if (message.returnValue.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.returnValue);
        /* int64 block_number = 6; */
        if (message.blockNumber !== 0n)
            writer.tag(6, WireType.Varint).int64(message.blockNumber);
        /* aelf.Hash block_hash = 7; */
        if (message.blockHash)
            Hash.internalBinaryWrite(message.blockHash, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string error = 10; */
        if (message.error !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.TransactionResult
 */
export const TransactionResult = new TransactionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogEvent$Type extends MessageType<LogEvent> {
    constructor() {
        super("aelf.LogEvent", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "indexed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "non_indexed", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LogEvent>): LogEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.indexed = [];
        message.nonIndexed = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LogEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogEvent): LogEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* aelf.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated bytes indexed */ 3:
                    message.indexed.push(reader.bytes());
                    break;
                case /* bytes non_indexed */ 4:
                    message.nonIndexed = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aelf.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated bytes indexed = 3; */
        for (let i = 0; i < message.indexed.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.indexed[i]);
        /* bytes non_indexed = 4; */
        if (message.nonIndexed.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.nonIndexed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.LogEvent
 */
export const LogEvent = new LogEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmartContractRegistration$Type extends MessageType<SmartContractRegistration> {
    constructor() {
        super("aelf.SmartContractRegistration", [
            { no: 1, name: "category", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "code", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "code_hash", kind: "message", T: () => Hash },
            { no: 4, name: "is_system_contract", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SmartContractRegistration>): SmartContractRegistration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.category = 0;
        message.code = new Uint8Array(0);
        message.isSystemContract = false;
        message.version = 0;
        if (value !== undefined)
            reflectionMergePartial<SmartContractRegistration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmartContractRegistration): SmartContractRegistration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 category */ 1:
                    message.category = reader.sint32();
                    break;
                case /* bytes code */ 2:
                    message.code = reader.bytes();
                    break;
                case /* aelf.Hash code_hash */ 3:
                    message.codeHash = Hash.internalBinaryRead(reader, reader.uint32(), options, message.codeHash);
                    break;
                case /* bool is_system_contract */ 4:
                    message.isSystemContract = reader.bool();
                    break;
                case /* int32 version */ 5:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmartContractRegistration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 category = 1; */
        if (message.category !== 0)
            writer.tag(1, WireType.Varint).sint32(message.category);
        /* bytes code = 2; */
        if (message.code.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.code);
        /* aelf.Hash code_hash = 3; */
        if (message.codeHash)
            Hash.internalBinaryWrite(message.codeHash, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_system_contract = 4; */
        if (message.isSystemContract !== false)
            writer.tag(4, WireType.Varint).bool(message.isSystemContract);
        /* int32 version = 5; */
        if (message.version !== 0)
            writer.tag(5, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.SmartContractRegistration
 */
export const SmartContractRegistration = new SmartContractRegistration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionExecutingStateSet$Type extends MessageType<TransactionExecutingStateSet> {
    constructor() {
        super("aelf.TransactionExecutingStateSet", [
            { no: 1, name: "writes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 12 /*ScalarType.BYTES*/ } },
            { no: 2, name: "reads", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 3, name: "deletes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<TransactionExecutingStateSet>): TransactionExecutingStateSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.writes = {};
        message.reads = {};
        message.deletes = {};
        if (value !== undefined)
            reflectionMergePartial<TransactionExecutingStateSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionExecutingStateSet): TransactionExecutingStateSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, bytes> writes */ 1:
                    this.binaryReadMap1(message.writes, reader, options);
                    break;
                case /* map<string, bool> reads */ 2:
                    this.binaryReadMap2(message.reads, reader, options);
                    break;
                case /* map<string, bool> deletes */ 3:
                    this.binaryReadMap3(message.deletes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TransactionExecutingStateSet["writes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TransactionExecutingStateSet["writes"] | undefined, val: TransactionExecutingStateSet["writes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.bytes();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field aelf.TransactionExecutingStateSet.writes");
            }
        }
        map[key ?? ""] = val ?? new Uint8Array(0);
    }
    private binaryReadMap2(map: TransactionExecutingStateSet["reads"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TransactionExecutingStateSet["reads"] | undefined, val: TransactionExecutingStateSet["reads"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field aelf.TransactionExecutingStateSet.reads");
            }
        }
        map[key ?? ""] = val ?? false;
    }
    private binaryReadMap3(map: TransactionExecutingStateSet["deletes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TransactionExecutingStateSet["deletes"] | undefined, val: TransactionExecutingStateSet["deletes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field aelf.TransactionExecutingStateSet.deletes");
            }
        }
        map[key ?? ""] = val ?? false;
    }
    internalBinaryWrite(message: TransactionExecutingStateSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, bytes> writes = 1; */
        for (let k of globalThis.Object.keys(message.writes))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).bytes(message.writes[k]).join();
        /* map<string, bool> reads = 2; */
        for (let k of globalThis.Object.keys(message.reads))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).bool(message.reads[k]).join();
        /* map<string, bool> deletes = 3; */
        for (let k of globalThis.Object.keys(message.deletes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).bool(message.deletes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.TransactionExecutingStateSet
 */
export const TransactionExecutingStateSet = new TransactionExecutingStateSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Address$Type extends MessageType<Address> {
    constructor() {
        super("aelf.Address", [
            { no: 1, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Address>): Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Address): Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes value */ 1:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes value = 1; */
        if (message.value.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.Address
 */
export const Address = new Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Hash$Type extends MessageType<Hash> {
    constructor() {
        super("aelf.Hash", [
            { no: 1, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Hash>): Hash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Hash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hash): Hash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes value */ 1:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Hash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes value = 1; */
        if (message.value.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.Hash
 */
export const Hash = new Hash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt32Value$Type extends MessageType<SInt32Value> {
    constructor() {
        super("aelf.SInt32Value", [
            { no: 1, name: "value", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SInt32Value>): SInt32Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<SInt32Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt32Value): SInt32Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 value */ 1:
                    message.value = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt32Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).sint32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.SInt32Value
 */
export const SInt32Value = new SInt32Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt64Value$Type extends MessageType<SInt64Value> {
    constructor() {
        super("aelf.SInt64Value", [
            { no: 1, name: "value", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SInt64Value>): SInt64Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<SInt64Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt64Value): SInt64Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 value */ 1:
                    message.value = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt64Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.SInt64Value
 */
export const SInt64Value = new SInt64Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MerklePath$Type extends MessageType<MerklePath> {
    constructor() {
        super("aelf.MerklePath", [
            { no: 1, name: "merkle_path_nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MerklePathNode }
        ]);
    }
    create(value?: PartialMessage<MerklePath>): MerklePath {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.merklePathNodes = [];
        if (value !== undefined)
            reflectionMergePartial<MerklePath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MerklePath): MerklePath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated aelf.MerklePathNode merkle_path_nodes */ 1:
                    message.merklePathNodes.push(MerklePathNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MerklePath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated aelf.MerklePathNode merkle_path_nodes = 1; */
        for (let i = 0; i < message.merklePathNodes.length; i++)
            MerklePathNode.internalBinaryWrite(message.merklePathNodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.MerklePath
 */
export const MerklePath = new MerklePath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MerklePathNode$Type extends MessageType<MerklePathNode> {
    constructor() {
        super("aelf.MerklePathNode", [
            { no: 1, name: "hash", kind: "message", T: () => Hash },
            { no: 2, name: "is_left_child_node", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MerklePathNode>): MerklePathNode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isLeftChildNode = false;
        if (value !== undefined)
            reflectionMergePartial<MerklePathNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MerklePathNode): MerklePathNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* aelf.Hash hash */ 1:
                    message.hash = Hash.internalBinaryRead(reader, reader.uint32(), options, message.hash);
                    break;
                case /* bool is_left_child_node */ 2:
                    message.isLeftChildNode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MerklePathNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* aelf.Hash hash = 1; */
        if (message.hash)
            Hash.internalBinaryWrite(message.hash, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_left_child_node = 2; */
        if (message.isLeftChildNode !== false)
            writer.tag(2, WireType.Varint).bool(message.isLeftChildNode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.MerklePathNode
 */
export const MerklePathNode = new MerklePathNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinaryMerkleTree$Type extends MessageType<BinaryMerkleTree> {
    constructor() {
        super("aelf.BinaryMerkleTree", [
            { no: 1, name: "nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Hash },
            { no: 2, name: "root", kind: "message", T: () => Hash },
            { no: 3, name: "leaf_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BinaryMerkleTree>): BinaryMerkleTree {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodes = [];
        message.leafCount = 0;
        if (value !== undefined)
            reflectionMergePartial<BinaryMerkleTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinaryMerkleTree): BinaryMerkleTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated aelf.Hash nodes */ 1:
                    message.nodes.push(Hash.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* aelf.Hash root */ 2:
                    message.root = Hash.internalBinaryRead(reader, reader.uint32(), options, message.root);
                    break;
                case /* int32 leaf_count */ 3:
                    message.leafCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinaryMerkleTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated aelf.Hash nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            Hash.internalBinaryWrite(message.nodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* aelf.Hash root = 2; */
        if (message.root)
            Hash.internalBinaryWrite(message.root, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 leaf_count = 3; */
        if (message.leafCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.leafCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.BinaryMerkleTree
 */
export const BinaryMerkleTree = new BinaryMerkleTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BigIntValue$Type extends MessageType<BigIntValue> {
    constructor() {
        super("aelf.BigIntValue", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BigIntValue>): BigIntValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<BigIntValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BigIntValue): BigIntValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BigIntValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aelf.BigIntValue
 */
export const BigIntValue = new BigIntValue$Type();
